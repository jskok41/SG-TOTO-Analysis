<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ TOTO Analysis & Prediction - Standalone</title>
    <meta name="description" content="Singapore TOTO Statistical Analysis and Number Prediction System">
    <meta name="keywords" content="TOTO, Singapore, lottery, prediction, analysis, statistics">
    <meta name="author" content="TOTO Analysis System">
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Recharts for charts -->
    <script src="https://unpkg.com/recharts/umd/Recharts.min.js"></script>
    
    <!-- Lucide React Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <style>
        /* Custom styles for the application */
        .gradient-bg {
            background: linear-gradient(135deg, #EBF4FF 0%, #E0E7FF 100%);
        }
        
        .card-hover {
            transition: all 0.3s ease;
        }
        
        .card-hover:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        
        .badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem;
            border: 1px solid #e5e7eb;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 500;
            background-color: #f9fafb;
            color: #374151;
        }
        
        .badge.primary {
            background-color: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            transition: width 0.3s ease;
        }
        
        .tab-button {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tab-button.active {
            background-color: #3b82f6;
            color: white;
        }
        
        .tab-button:not(.active) {
            background-color: transparent;
            color: #6b7280;
        }
        
        .tab-button:not(.active):hover {
            background-color: #f3f4f6;
        }

        .refresh-button {
            background: linear-gradient(135deg, #10b981, #059669);
            transition: all 0.3s ease;
        }
        
        .refresh-button:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        .refresh-button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .status-indicator.success {
            background-color: #d1fae5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }
        
        .status-indicator.error {
            background-color: #fee2e2;
            color: #991b1b;
            border: 1px solid #fca5a5;
        }
        
        .status-indicator.loading {
            background-color: #dbeafe;
            color: #1e40af;
            border: 1px solid #93c5fd;
        }
    </style>
</head>
<body class="gradient-bg min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900 mb-2">
                üéØ TOTO Analysis & Prediction
            </h1>
            <p class="text-lg text-gray-600">
                Singapore TOTO Statistical Analysis and Number Prediction System
            </p>
            <p class="text-sm text-gray-500 mt-2">
                üì± Standalone Version - Works on any mobile browser
            </p>
            
            <!-- Refresh Section -->
            <div class="mt-6 flex flex-col sm:flex-row items-center justify-center gap-4">
                <button id="refresh-latest-btn" class="refresh-button text-white px-6 py-3 rounded-lg font-medium flex items-center gap-2">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    üîÑ Fetch Latest TOTO Results
                </button>
                <div id="status-indicator" class="status-indicator success">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                    </svg>
                    <span id="status-text">Ready to fetch latest results</span>
                </div>
            </div>
            
            <!-- Last Updated Info -->
            <div class="mt-4 text-sm text-gray-500">
                <span id="last-updated">Last updated: Loading...</span>
                <span id="data-source" class="ml-2">Source: Real TOTO data scraping</span>
            </div>
        </div>

        <!-- Summary Cards -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
            <div class="bg-white rounded-lg shadow-md p-6 card-hover">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="text-sm font-medium text-gray-600">Total Draws</h3>
                    <span class="text-gray-400">üìÖ</span>
                </div>
                <div class="text-2xl font-bold text-gray-900" id="total-draws">Loading...</div>
                <p class="text-xs text-gray-500" id="date-range">Analyzing data...</p>
            </div>

            <div class="bg-white rounded-lg shadow-md p-6 card-hover">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="text-sm font-medium text-gray-600">Most Frequent</h3>
                    <span class="text-gray-400">üìà</span>
                </div>
                <div class="text-2xl font-bold text-gray-900" id="most-frequent">Loading...</div>
                <p class="text-xs text-gray-500" id="most-frequent-details">Analyzing patterns...</p>
            </div>

            <div class="bg-white rounded-lg shadow-md p-6 card-hover">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="text-sm font-medium text-gray-600">Least Frequent</h3>
                    <span class="text-gray-400">üìâ</span>
                </div>
                <div class="text-2xl font-bold text-gray-900" id="least-frequent">Loading...</div>
                <p class="text-xs text-gray-500" id="least-frequent-details">Analyzing patterns...</p>
            </div>

            <div class="bg-white rounded-lg shadow-md p-6 card-hover">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="text-sm font-medium text-gray-600">Prediction Methods</h3>
                    <span class="text-gray-400">üéØ</span>
                </div>
                <div class="text-2xl font-bold text-gray-900">7</div>
                <p class="text-xs text-gray-500">Advanced chronological algorithms</p>
            </div>
        </div>

        <!-- Tabs -->
        <div class="bg-white rounded-lg shadow-md p-6">
            <div class="flex space-x-2 mb-6 border-b">
                <button class="tab-button active" onclick="showTab('predictions')">üéØ Predictions</button>
                <button class="tab-button" onclick="showTab('statistics')">üìä Statistics</button>
                <button class="tab-button" onclick="showTab('charts')">üìà Charts</button>
                <button class="tab-button" onclick="showTab('data')">üìã Data</button>
            </div>

            <!-- Predictions Tab -->
            <div id="predictions-tab" class="tab-content">
                <div class="mb-4 flex items-center justify-between">
                    <h3 class="font-semibold text-lg">TOTO Predictions</h3>
                    <button id="recompute-btn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200 flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                        </svg>
                        Recompute Predictions
                    </button>
                </div>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6" id="predictions-container">
                    <div class="text-center py-8">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
                        <p class="mt-2 text-gray-600">Generating predictions...</p>
                    </div>
                </div>
            </div>

            <!-- Statistics Tab -->
            <div id="statistics-tab" class="tab-content hidden">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-gray-50 rounded-lg p-4">
                        <h3 class="font-semibold mb-4">Most Frequent Numbers</h3>
                        <div id="most-frequent-list" class="space-y-2">
                            <div class="text-center py-4">
                                <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600 mx-auto"></div>
                            </div>
                        </div>
                    </div>
                    <div class="bg-gray-50 rounded-lg p-4">
                        <h3 class="font-semibold mb-4">Least Frequent Numbers</h3>
                        <div id="least-frequent-list" class="space-y-2">
                            <div class="text-center py-4">
                                <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600 mx-auto"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Charts Tab -->
            <div id="charts-tab" class="tab-content hidden">
                <div class="bg-gray-50 rounded-lg p-4">
                    <h3 class="font-semibold mb-4">Frequency Distribution</h3>
                    
                    <!-- Prediction Method Filters -->
                    <div class="mb-6 bg-white rounded-lg p-4 shadow-sm">
                        <h4 class="font-medium mb-3 text-gray-700">Show Prediction Methods:</h4>
                        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3" id="prediction-checkboxes">
                            <!-- Checkboxes will be dynamically generated here -->
                        </div>
                        <div class="mt-3 pt-3 border-t border-gray-200">
                            <button id="select-all-predictions" class="text-sm text-blue-600 hover:text-blue-800 mr-4">Select All</button>
                            <button id="clear-all-predictions" class="text-sm text-gray-600 hover:text-gray-800">Clear All</button>
                        </div>
                    </div>

                    <div id="chart-container" class="w-full" style="min-height: 800px;">
                        <canvas id="frequencyChart" style="width: 100%; max-width: 1400px; height: auto;"></canvas>
                    </div>
                </div>
            </div>

            <!-- Data Tab -->
            <div id="data-tab" class="tab-content hidden">
                <div class="bg-gray-50 rounded-lg p-4">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="font-semibold">Historical TOTO Results</h3>
                        <span class="text-sm text-gray-600" id="data-count">Loading...</span>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="border-b bg-gray-100">
                                    <th class="text-left p-3 font-semibold">Date</th>
                                    <th class="text-left p-3 font-semibold">Winning Numbers</th>
                                    <th class="text-left p-3 font-semibold">Additional Number</th>
                                </tr>
                            </thead>
                            <tbody id="data-table">
                                <tr>
                                    <td colspan="3" class="text-center py-4">
                                        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600 mx-auto"></div>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="mt-8 text-center text-sm text-gray-500">
            <p>üéØ TOTO Analysis & Prediction System</p>
            <p class="mt-1">Built with Next.js, TypeScript, Tailwind CSS, and Recharts</p>
            <p class="mt-1 text-xs">‚ö†Ô∏è This is for educational purposes only. No guarantees on predictions.</p>
        </div>
    </div>

    <script>
        // Embedded TOTO data (Real Singapore TOTO Results)
        const totoData = [
            {"Date": "2025-07-28", "Winning Number 1": 2, "2": 14, "3": 16, "4": 21, "5": 36, "6": 47, "Additional Number": 1},
            {"Date": "2025-07-24", "Winning Number 1": 9, "2": 11, "3": 24, "4": 32, "5": 39, "6": 49, "Additional Number": 26},
            {"Date": "2025-07-21", "Winning Number 1": 2, "2": 5, "3": 10, "4": 12, "5": 14, "6": 37, "Additional Number": 17},
            {"Date": "2025-07-17", "Winning Number 1": 7, "2": 8, "3": 17, "4": 29, "5": 32, "6": 42, "Additional Number": 1},
            {"Date": "2025-07-14", "Winning Number 1": 2, "2": 8, "3": 19, "4": 29, "5": 38, "6": 41, "Additional Number": 20},
            {"Date": "2025-07-10", "Winning Number 1": 12, "2": 21, "3": 26, "4": 27, "5": 35, "6": 44, "Additional Number": 10},
            {"Date": "2025-07-07", "Winning Number 1": 10, "2": 15, "3": 17, "4": 33, "5": 36, "6": 45, "Additional Number": 34},
            {"Date": "2025-07-03", "Winning Number 1": 6, "2": 15, "3": 16, "4": 17, "5": 25, "6": 34, "Additional Number": 31},
            {"Date": "2025-06-30", "Winning Number 1": 11, "2": 27, "3": 31, "4": 33, "5": 34, "6": 36, "Additional Number": 13},
            {"Date": "2025-06-26", "Winning Number 1": 10, "2": 26, "3": 28, "4": 35, "5": 37, "6": 46, "Additional Number": 20},
            {"Date": "2025-06-23", "Winning Number 1": 2, "2": 15, "3": 29, "4": 37, "5": 45, "6": 49, "Additional Number": 24},
            {"Date": "2025-06-19", "Winning Number 1": 1, "2": 10, "3": 37, "4": 40, "5": 45, "6": 47, "Additional Number": 19},
            {"Date": "2025-06-16", "Winning Number 1": 5, "2": 18, "3": 27, "4": 32, "5": 48, "6": 49, "Additional Number": 21},
            {"Date": "2025-06-12", "Winning Number 1": 3, "2": 7, "3": 38, "4": 41, "5": 44, "6": 49, "Additional Number": 20},
            {"Date": "2025-06-09", "Winning Number 1": 7, "2": 10, "3": 11, "4": 21, "5": 32, "6": 48, "Additional Number": 27},
            {"Date": "2025-06-05", "Winning Number 1": 2, "2": 5, "3": 25, "4": 26, "5": 29, "6": 30, "Additional Number": 42},
            {"Date": "2025-06-02", "Winning Number 1": 10, "2": 19, "3": 21, "4": 22, "5": 28, "6": 31, "Additional Number": 34},
            {"Date": "2025-05-29", "Winning Number 1": 1, "2": 5, "3": 7, "4": 11, "5": 19, "6": 47, "Additional Number": 44},
            {"Date": "2025-05-26", "Winning Number 1": 5, "2": 9, "3": 15, "4": 28, "5": 46, "6": 48, "Additional Number": 8},
            {"Date": "2025-05-22", "Winning Number 1": 3, "2": 10, "3": 32, "4": 34, "5": 44, "6": 48, "Additional Number": 29},
            {"Date": "2025-05-19", "Winning Number 1": 2, "2": 15, "3": 17, "4": 18, "5": 39, "6": 45, "Additional Number": 26},
            {"Date": "2025-05-15", "Winning Number 1": 9, "2": 16, "3": 17, "4": 20, "5": 34, "6": 38, "Additional Number": 18},
            {"Date": "2025-05-12", "Winning Number 1": 6, "2": 16, "3": 20, "4": 23, "5": 40, "6": 48, "Additional Number": 45},
            {"Date": "2025-05-08", "Winning Number 1": 9, "2": 13, "3": 17, "4": 39, "5": 46, "6": 47, "Additional Number": 22},
            {"Date": "2025-05-05", "Winning Number 1": 5, "2": 8, "3": 28, "4": 38, "5": 40, "6": 43, "Additional Number": 39},
            {"Date": "2025-05-01", "Winning Number 1": 2, "2": 8, "3": 12, "4": 30, "5": 35, "6": 49, "Additional Number": 38},
            {"Date": "2025-04-28", "Winning Number 1": 3, "2": 8, "3": 12, "4": 18, "5": 24, "6": 41, "Additional Number": 11},
            {"Date": "2025-04-24", "Winning Number 1": 17, "2": 19, "3": 21, "4": 23, "5": 30, "6": 40, "Additional Number": 33},
            {"Date": "2025-04-21", "Winning Number 1": 1, "2": 17, "3": 30, "4": 37, "5": 41, "6": 43, "Additional Number": 32},
            {"Date": "2025-04-17", "Winning Number 1": 15, "2": 17, "3": 26, "4": 31, "5": 40, "6": 46, "Additional Number": 19},
            {"Date": "2025-04-14", "Winning Number 1": 6, "2": 14, "3": 29, "4": 30, "5": 35, "6": 42, "Additional Number": 25},
            {"Date": "2025-04-10", "Winning Number 1": 14, "2": 26, "3": 27, "4": 30, "5": 46, "6": 48, "Additional Number": 10},
            {"Date": "2025-04-07", "Winning Number 1": 7, "2": 19, "3": 35, "4": 40, "5": 43, "6": 47, "Additional Number": 33},
            {"Date": "2025-04-03", "Winning Number 1": 12, "2": 14, "3": 15, "4": 16, "5": 21, "6": 40, "Additional Number": 23},
            {"Date": "2025-03-31", "Winning Number 1": 9, "2": 12, "3": 17, "4": 23, "5": 29, "6": 46, "Additional Number": 20},
            {"Date": "2025-03-27", "Winning Number 1": 21, "2": 22, "3": 27, "4": 35, "5": 40, "6": 42, "Additional Number": 3},
            {"Date": "2025-03-24", "Winning Number 1": 18, "2": 19, "3": 25, "4": 28, "5": 31, "6": 44, "Additional Number": 34},
            {"Date": "2025-03-20", "Winning Number 1": 9, "2": 10, "3": 11, "4": 13, "5": 23, "6": 42, "Additional Number": 20},
            {"Date": "2025-03-17", "Winning Number 1": 7, "2": 30, "3": 39, "4": 42, "5": 43, "6": 48, "Additional Number": 33},
            {"Date": "2025-03-13", "Winning Number 1": 16, "2": 26, "3": 34, "4": 36, "5": 42, "6": 49, "Additional Number": 41},
            {"Date": "2025-03-10", "Winning Number 1": 5, "2": 7, "3": 32, "4": 38, "5": 42, "6": 47, "Additional Number": 27},
            {"Date": "2025-03-06", "Winning Number 1": 19, "2": 33, "3": 35, "4": 38, "5": 46, "6": 49, "Additional Number": 39},
            {"Date": "2025-03-03", "Winning Number 1": 4, "2": 16, "3": 24, "4": 25, "5": 43, "6": 49, "Additional Number": 46},
            {"Date": "2025-02-27", "Winning Number 1": 2, "2": 10, "3": 13, "4": 15, "5": 37, "6": 40, "Additional Number": 28},
            {"Date": "2025-02-24", "Winning Number 1": 24, "2": 37, "3": 38, "4": 42, "5": 48, "6": 49, "Additional Number": 31},
            {"Date": "2025-02-20", "Winning Number 1": 3, "2": 25, "3": 31, "4": 37, "5": 39, "6": 42, "Additional Number": 21},
            {"Date": "2025-02-17", "Winning Number 1": 1, "2": 16, "3": 23, "4": 39, "5": 41, "6": 42, "Additional Number": 9},
            {"Date": "2025-02-13", "Winning Number 1": 5, "2": 8, "3": 13, "4": 28, "5": 30, "6": 49, "Additional Number": 17},
            {"Date": "2025-02-10", "Winning Number 1": 1, "2": 3, "3": 7, "4": 18, "5": 34, "6": 39, "Additional Number": 46},
            {"Date": "2025-02-07", "Winning Number 1": 16, "2": 18, "3": 22, "4": 23, "5": 28, "6": 35, "Additional Number": 32}
        ];

        // Real TOTO data fetching functions with timeout
        async function fetchRealTotoResults() {
            console.log('Attempting to fetch real TOTO data...');
            
            // Set maximum time for real data fetching (5 seconds)
            const fetchTimeout = 5000;
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Fetch timeout')), fetchTimeout)
            );
            
            try {
                const result = await Promise.race([
                    attemptRealDataFetch(),
                    timeoutPromise
                ]);
                return result;
            } catch (error) {
                console.log('Real data fetch failed or timed out:', error.message);
                return null;
            }
        }
        
        async function attemptRealDataFetch() {
            // Multiple data sources for comprehensive scraping
            const dataSources = [
                {
                    name: 'Lottolyzer TOTO History',
                    url: 'https://en.lottolyzer.com/history/singapore/toto/page/1/per-page/50/summary-view',
                    parser: parseLottolyyzerResults
                },
                {
                    name: 'Singapore Pools Official Results',
                    url: 'https://www.singaporepools.com.sg/en/lottery/toto/results',
                    parser: parseOfficialWebsite
                },
                {
                    name: 'Singapore Pools API',
                    url: 'https://api.singaporepools.com.sg/api/v1/lottery/toto/results',
                    parser: parseOfficialAPI
                },
                {
                    name: 'Singapore Pools Mobile',
                    url: 'https://m.singaporepools.com.sg/en/lottery/toto/results',
                    parser: parseOfficialWebsite
                },
                {
                    name: 'Lottery Results API',
                    url: 'https://api.lottery.net/singapore/toto/results',
                    parser: parseLotteryAPI
                }
            ];
            
            // Try multiple proxies for each source - using more reliable CORS proxies
            const proxyServices = [
                'https://api.allorigins.win/get?url=',
                'https://api.codetabs.com/v1/proxy?quest=',
                'https://corsproxy.io/?',
                'https://cors.sh/',
                'https://proxy.cors.sh/'
            ];
            
            for (const source of dataSources) {
                console.log(`Attempting to scrape from ${source.name}...`);
                
                for (const proxyBase of proxyServices) {
                    try {
                        const proxyUrl = proxyBase.includes('?') 
                            ? proxyBase + encodeURIComponent(source.url)
                            : proxyBase + source.url;
                        
                        console.log(`Using proxy for ${source.name}: ${proxyBase}`);
                        
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout per request
                        
                        const response = await fetch(proxyUrl, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json, text/html, */*',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                                'Cache-Control': 'no-cache',
                                'Pragma': 'no-cache'
                            },
                            signal: controller.signal,
                            mode: 'cors',
                            credentials: 'omit'
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (response.ok) {
                            const data = await response.text();
                            console.log(`‚úÖ Successfully fetched data from ${source.name} via ${proxyBase}`);
                            console.log(`üìä Data size: ${data.length} characters`);
                            
                            // Log first 1000 characters of response for debugging
                            console.log('üìÑ Response preview:', data.substring(0, 1000));
                            
                            // Parse the data using the appropriate parser
                            console.log(`üîç Attempting to parse data with ${source.parser.name}...`);
                            const parsedData = source.parser(data);
                            
                            if (parsedData && parsedData.length > 0) {
                                console.log(`üéâ Successfully parsed ${parsedData.length} TOTO draws from ${source.name}`);
                                console.log('üìã Sample parsed data:', parsedData[0]);
                                return parsedData;
                            } else {
                                console.log(`‚ùå No valid TOTO data found in response from ${source.name}`);
                                console.log(`‚ùì Parser returned:`, parsedData);
                            }
                        } else {
                            console.log(`‚ùå HTTP ${response.status} ${response.statusText} from ${source.name} via ${proxyBase}`);
                            const errorText = await response.text();
                            console.log('Error response preview:', errorText.substring(0, 500));
                        }
                        
                    } catch (sourceError) {
                        console.log(`${source.name} via ${proxyBase} failed:`, sourceError.message);
                    }
                }
            }
            
            throw new Error('All scraping sources and proxies failed');
        }
        
        function parseOfficialAPI(data) {
            try {
                console.log('=== PARSING OFFICIAL API DATA ===');
                let jsonContent = data;
                
                // Handle allorigins.win wrapper
                if (typeof data === 'string' && data.includes('"contents"')) {
                    console.log('Detected allorigins wrapper, extracting contents...');
                    const parsed = JSON.parse(data);
                    jsonContent = parsed.contents || data;
                }
                
                const results = JSON.parse(jsonContent);
                console.log('API response structure:', Object.keys(results));
                
                if (results && Array.isArray(results)) {
                    console.log(`Found ${results.length} results in API response`);
                    return results.map((result, index) => {
                        console.log(`Processing API result ${index}:`, result);
                        return {
                            "Date": result.date || result.drawDate || result.Date,
                            "Winning Number 1": parseInt(result.winningNumbers?.[0] || result.numbers?.[0]),
                            "2": parseInt(result.winningNumbers?.[1] || result.numbers?.[1]),
                            "3": parseInt(result.winningNumbers?.[2] || result.numbers?.[2]),
                            "4": parseInt(result.winningNumbers?.[3] || result.numbers?.[3]),
                            "5": parseInt(result.winningNumbers?.[4] || result.numbers?.[4]),
                            "6": parseInt(result.winningNumbers?.[5] || result.numbers?.[5]),
                            "Additional Number": parseInt(result.additionalNumber || result.additional || result.bonus)
                        };
                    }).filter(result => {
                        // Filter out invalid results
                        const isValid = result.Date && 
                                       !isNaN(result['Winning Number 1']) && 
                                       !isNaN(result['2']) && 
                                       !isNaN(result['3']) && 
                                       !isNaN(result['4']) && 
                                       !isNaN(result['5']) && 
                                       !isNaN(result['6']) && 
                                       !isNaN(result['Additional Number']);
                        if (!isValid) {
                            console.log('Filtering out invalid result:', result);
                        }
                        return isValid;
                    });
                } else if (results && results.data && Array.isArray(results.data)) {
                    // Handle wrapped response format
                    console.log(`Found ${results.data.length} results in wrapped API response`);
                    return results.data.map(result => ({
                        "Date": result.date || result.drawDate || result.Date,
                        "Winning Number 1": parseInt(result.winningNumbers?.[0] || result.numbers?.[0]),
                        "2": parseInt(result.winningNumbers?.[1] || result.numbers?.[1]),
                        "3": parseInt(result.winningNumbers?.[2] || result.numbers?.[2]),
                        "4": parseInt(result.winningNumbers?.[3] || result.numbers?.[3]),
                        "5": parseInt(result.winningNumbers?.[4] || result.numbers?.[4]),
                        "6": parseInt(result.winningNumbers?.[5] || result.numbers?.[5]),
                        "Additional Number": parseInt(result.additionalNumber || result.additional || result.bonus)
                    }));
                }
            } catch (error) {
                console.log('Failed to parse official API data:', error.message);
                console.log('Data preview:', data?.substring(0, 200));
            }
            return null;
        }
        
        function parseOfficialWebsite(data) {
            try {
                // Handle allorigins.win wrapper
                if (data.includes('"contents"')) {
                    const jsonData = JSON.parse(data);
                    data = jsonData.contents;
                }
                
                // Parse HTML for TOTO results
                const parser = new DOMParser();
                const doc = parser.parseFromString(data, 'text/html');
                
                const results = [];
                
                // Look for common patterns in Singapore Pools website
                const resultRows = doc.querySelectorAll('tr, .result-row, .draw-result');
                
                resultRows.forEach(row => {
                    const text = row.textContent || row.innerHTML;
                    
                    // Pattern: DD/MM/YYYY followed by 6 numbers
                    const dateMatch = text.match(/(\d{2}\/\d{2}\/\d{4}|\d{4}-\d{2}-\d{2})/);
                    const numbersMatch = text.match(/\b(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})\b/);
                    const additionalMatch = text.match(/additional.*?(\d{1,2})/i);
                    
                    if (dateMatch && numbersMatch) {
                        let date = dateMatch[1];
                        if (date.includes('/')) {
                            // Convert DD/MM/YYYY to YYYY-MM-DD
                            const parts = date.split('/');
                            date = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                        }
                        
                        const numbers = numbersMatch.slice(1, 7).map(n => parseInt(n)).filter(n => n >= 1 && n <= 49);
                        const additional = additionalMatch ? parseInt(additionalMatch[1]) : Math.floor(Math.random() * 49) + 1;
                        
                        if (numbers.length === 6) {
                            results.push({
                                "Date": date,
                                "Winning Number 1": numbers[0],
                                "2": numbers[1],
                                "3": numbers[2],
                                "4": numbers[3],
                                "5": numbers[4],
                                "6": numbers[5],
                                "Additional Number": additional
                            });
                        }
                    }
                });
                
                return results.slice(0, 5); // Return latest 5 draws
                
            } catch (error) {
                console.log('Failed to parse official website data:', error);
            }
            return null;
        }
        
        function parseLotteryAPI(data) {
            try {
                // Handle allorigins.win wrapper
                if (data.includes('"contents"')) {
                    const jsonData = JSON.parse(data);
                    data = jsonData.contents;
                }
                
                const results = JSON.parse(data);
                if (results && results.results) {
                    return results.results.map(result => ({
                        "Date": result.date,
                        "Winning Number 1": parseInt(result.numbers[0]),
                        "2": parseInt(result.numbers[1]),
                        "3": parseInt(result.numbers[2]),
                        "4": parseInt(result.numbers[3]),
                        "5": parseInt(result.numbers[4]),
                        "6": parseInt(result.numbers[5]),
                        "Additional Number": parseInt(result.bonus || result.additional)
                    }));
                }
            } catch (error) {
                console.log('Failed to parse lottery API data:', error);
            }
            return null;
        }
        
        function parseLottolyyzerResults(data) {
            try {
                console.log('=== PARSING LOTTOLYZER DATA ===');
                console.log('Data type:', typeof data);
                console.log('Data length:', data?.length || 'N/A');
                
                // Handle allorigins wrapper
                let htmlContent = data;
                if (typeof data === 'string' && data.includes('"contents"')) {
                    console.log('Detected allorigins wrapper, extracting contents...');
                    const parsed = JSON.parse(data);
                    htmlContent = parsed.contents || data;
                    console.log('Extracted content length:', htmlContent?.length || 'N/A');
                }
                
                // Log a sample of the content for debugging
                const contentSample = htmlContent.substring(0, 500);
                console.log('Content sample:', contentSample);
                
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');
                
                // Try different table selectors
                let tableRows = doc.querySelectorAll('table tr');
                console.log(`Found ${tableRows.length} table rows with 'table tr' selector`);
                
                if (tableRows.length === 0) {
                    // Try alternative selectors
                    tableRows = doc.querySelectorAll('tr');
                    console.log(`Found ${tableRows.length} rows with 'tr' selector`);
                }
                
                const results = [];
                
                for (let i = 0; i < tableRows.length; i++) {
                    const row = tableRows[i];
                    const cells = row.querySelectorAll('td');
                    
                    // Log the first few rows for debugging
                    if (i < 5) {
                        console.log(`Row ${i}: ${cells.length} cells`);
                        for (let j = 0; j < Math.min(cells.length, 5); j++) {
                            console.log(`  Cell ${j}: "${cells[j]?.textContent?.trim()?.substring(0, 50)}"`);
                        }
                    }
                    
                    // Skip header rows and rows without enough cells
                    if (cells.length < 4) continue;
                    
                    try {
                        // Extract draw number, date, and winning numbers
                        const drawNum = cells[0]?.textContent?.trim();
                        const dateText = cells[1]?.textContent?.trim();
                        const winningNumsText = cells[2]?.textContent?.trim();
                        const additionalNumText = cells[3]?.textContent?.trim();
                        
                        console.log(`Row ${i} data: Draw="${drawNum}", Date="${dateText}", Numbers="${winningNumsText}", Additional="${additionalNumText}"`);
                        
                        // Skip if essential data is missing
                        if (!drawNum || !dateText || !winningNumsText || !additionalNumText) {
                            console.log(`Skipping row ${i}: Missing essential data`);
                            continue;
                        }
                        
                        // Check if this looks like a valid draw number (should be numeric)
                        const drawNumber = parseInt(drawNum);
                        if (isNaN(drawNumber)) {
                            console.log(`Skipping row ${i}: Invalid draw number "${drawNum}"`);
                            continue;
                        }
                        
                        // Parse date (format: YYYY-MM-DD)
                        const dateMatch = dateText.match(/(\d{4})-(\d{2})-(\d{2})/);
                        if (!dateMatch) {
                            console.log(`Skipping row ${i}: Invalid date format "${dateText}"`);
                            continue;
                        }
                        
                        const formattedDate = `${dateMatch[1]}-${dateMatch[2]}-${dateMatch[3]}`;
                        
                        // Parse winning numbers (format: "30,32,40,43,45,49")
                        const winningNumbers = winningNumsText.split(',')
                            .map(num => parseInt(num.trim()))
                            .filter(num => !isNaN(num) && num >= 1 && num <= 49);
                        
                        // Parse additional number
                        const additionalNumber = parseInt(additionalNumText.trim());
                        
                        console.log(`Row ${i} parsed: Numbers=[${winningNumbers.join(',')}], Additional=${additionalNumber}`);
                        
                        // Validate we have exactly 6 winning numbers and 1 additional number
                        if (winningNumbers.length === 6 && !isNaN(additionalNumber) && additionalNumber >= 1 && additionalNumber <= 49) {
                            
                            // Sort winning numbers
                            winningNumbers.sort((a, b) => a - b);
                            
                            const result = {
                                "Date": formattedDate,
                                "Winning Number 1": winningNumbers[0],
                                "2": winningNumbers[1], 
                                "3": winningNumbers[2],
                                "4": winningNumbers[3],
                                "5": winningNumbers[4],
                                "6": winningNumbers[5],
                                "Additional Number": additionalNumber
                            };
                            
                            results.push(result);
                            console.log(`‚úÖ Successfully parsed draw ${drawNumber} (${formattedDate}): ${winningNumbers.join(',')} + ${additionalNumber}`);
                        } else {
                            console.log(`‚ùå Invalid data format for row ${i}: ${winningNumbers.length} numbers, additional: ${additionalNumber}`);
                        }
                        
                    } catch (rowError) {
                        console.log(`Error parsing row ${i}:`, rowError.message);
                        continue;
                    }
                }
                
                console.log(`=== LOTTOLYZER PARSING COMPLETE ===`);
                console.log(`Successfully parsed ${results.length} TOTO draws from Lottolyzer`);
                
                if (results.length > 0) {
                    console.log('Sample result:', results[0]);
                    // Return latest 10 draws (already sorted by date desc in the source)
                    return results.slice(0, 10);
                } else {
                    console.log('‚ùå No valid TOTO draws found in Lottolyzer data');
                    return null;
                }
                
            } catch (error) {
                console.log('‚ùå Error parsing Lottolyzer data:', error.message);
                console.log('Error stack:', error.stack);
                return null;
            }
        }
        
        function generateSimulatedDraw() {
            const today = new Date();
            const newDate = today.toISOString().split('T')[0];
            const numbers = generateSmartNumbers();
            
            let additionalNumber;
            do {
                additionalNumber = Math.floor(Math.random() * 49) + 1;
            } while (numbers.includes(additionalNumber));
            
            return {
                "Date": newDate,
                "Winning Number 1": numbers[0],
                "2": numbers[1],
                "3": numbers[2],
                "4": numbers[3],
                "5": numbers[4],
                "6": numbers[5],
                "Additional Number": additionalNumber
            };
        }

        // Helper function to get winning numbers from any row format
        function getWinningNumbers(row) {
            return [
                row['Number 1'] || row['Winning Number 1'],
                row['Number 2'] || row['2'], 
                row['Number 3'] || row['3'], 
                row['Number 4'] || row['4'], 
                row['Number 5'] || row['5'], 
                row['Number 6'] || row['6']
            ].filter(num => num !== undefined && num !== null);
        }

        // Web scraping and data refresh functions
        async function fetchLatestTotoData() {
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            const refreshBtn = document.getElementById('refresh-latest-btn');
            
            // Update status to loading
            statusIndicator.className = 'status-indicator loading';
            statusText.textContent = 'Fetching latest TOTO results...';
            refreshBtn.disabled = true;
            
            try {
                console.log('=== FETCHING REAL TOTO DATA ONLY ===');
                console.log('Current totoData length:', totoData.length);
                
                const existingDates = totoData.map(item => item.Date);
                console.log('Latest existing date:', existingDates[0]);
                
                // Update status to show we're scraping
                statusText.textContent = 'Scraping TOTO data from Lottolyzer & official sources...';
                
                // Attempt to fetch real data with extended timeout for thorough scraping
                console.log('Attempting to scrape real TOTO data from official sources...');
                
                let realData = null;
                try {
                    // Give more time for real data scraping (10 seconds)
                    realData = await Promise.race([
                        fetchRealTotoResults(),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Scraping timeout after 10 seconds')), 10000)
                        )
                    ]);
                } catch (timeoutError) {
                    console.log('Real data scraping timed out or failed:', timeoutError.message);
                    statusIndicator.className = 'status-indicator error';
                    statusText.textContent = 'Failed to fetch real TOTO data from official sources';
                    return;
                }
                
                if (realData && realData.length > 0) {
                    console.log('Successfully scraped real data:', realData);
                    
                    // Filter out data we already have
                    const newRealData = realData.filter(draw => !existingDates.includes(draw.Date));
                    
                    if (newRealData.length > 0) {
                        // Add new real data to the beginning
                        newRealData.forEach(draw => {
                            totoData.unshift(draw);
                        });
                        
                        // Sort by date (newest first)
                        totoData.sort((a, b) => new Date(b.Date) - new Date(a.Date));
                        
                        console.log('Added', newRealData.length, 'new real TOTO draws');
                        
                        // Update status to success
                        statusIndicator.className = 'status-indicator success';
                        statusText.textContent = `Successfully added ${newRealData.length} real TOTO draws!`;
                        
                        // Update data source info
                        document.getElementById('data-source').textContent = 'Source: Lottolyzer.com & Official Sources (Latest Scraped Data)';
                        
                        // Update last updated timestamp
                        document.getElementById('last-updated').textContent = 
                            `Last updated: ${new Date().toLocaleString()}`;
                        
                        // Refresh all displays
                        refreshAllDisplays();
                        
                        console.log('Successfully added real TOTO data! Total draws:', totoData.length);
                        
                    } else {
                        statusIndicator.className = 'status-indicator success';
                        statusText.textContent = 'No new TOTO draws available (already up to date)';
                        console.log('All scraped data already exists in our database');
                        
                        // Update timestamp even if no new data
                        document.getElementById('last-updated').textContent = 
                            `Last checked: ${new Date().toLocaleString()}`;
                    }
                    
                } else {
                    // No real data could be scraped - use embedded data as reliable fallback
                    console.log('‚ùå No real TOTO data could be scraped from official sources');
                    console.log('üîç This could be due to:');
                    console.log('  - CORS restrictions blocking the requests');
                    console.log('  - Proxy services being unavailable');
                    console.log('  - Website structure changes');
                    console.log('  - Network connectivity issues');
                    console.log('‚úÖ Using embedded data as fallback to ensure app functionality');
                    
                    statusIndicator.className = 'status-indicator success';
                    statusText.textContent = 'Using embedded TOTO data (Latest: ' + totoData[0].Date + ') - External sources unavailable';
                    
                    // Update timestamp
                    document.getElementById('last-updated').textContent = 
                        `Last checked: ${new Date().toLocaleString()} (Using embedded data)`;
                    
                    // Show helpful message
                    console.log('üí° App is fully functional with embedded historical data');
                    console.log('üí° For latest results, check Singapore Pools official website manually');
                }
                
            } catch (error) {
                console.error('Error while scraping TOTO data:', error);
                console.log('‚úÖ Falling back to embedded data to ensure app functionality');
                
                statusIndicator.className = 'status-indicator success';
                statusText.textContent = 'Using embedded TOTO data (Latest: ' + totoData[0].Date + ') - Network error occurred';
                
                // Update timestamp
                document.getElementById('last-updated').textContent = 
                    `Last checked: ${new Date().toLocaleString()} (Network error, using embedded data)`;
            } finally {
                // Re-enable refresh button
                refreshBtn.disabled = false;
            }
                }
        
        function showManualDataEntry() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            content.innerHTML = `
                <h2 style="color: #1f2937; margin-bottom: 20px;">üìã Manual TOTO Data Entry</h2>
                <p style="color: #6b7280; margin-bottom: 20px;">
                    Since automatic scraping failed due to CORS restrictions, you can manually enter the latest TOTO results from 
                    <a href="https://en.lottolyzer.com/history/singapore/toto/page/1/per-page/50/summary-view" target="_blank" style="color: #3b82f6;">Lottolyzer.com</a>
                </p>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 10px;">üìÖ Draw Date (YYYY-MM-DD):</label>
                    <input type="date" id="manual-date" style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 5px;">
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 10px;">üé≤ Draw Number:</label>
                    <input type="number" id="manual-draw" placeholder="e.g., 4101" style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 5px;">
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 10px;">üéØ Winning Numbers (6 numbers, comma-separated):</label>
                    <input type="text" id="manual-numbers" placeholder="e.g., 30,32,40,43,45,49" style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 5px;">
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 10px;">‚ûï Additional Number:</label>
                    <input type="number" id="manual-additional" placeholder="e.g., 5" min="1" max="49" style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 5px;">
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="cancel-manual" style="padding: 10px 20px; background: #6b7280; color: white; border: none; border-radius: 5px; cursor: pointer;">Cancel</button>
                    <button id="add-manual" style="padding: 10px 20px; background: #3b82f6; color: white; border: none; border-radius: 5px; cursor: pointer;">Add TOTO Data</button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Set today's date as default
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('manual-date').value = today;
            
            // Event handlers
            document.getElementById('cancel-manual').onclick = () => {
                document.body.removeChild(modal);
            };
            
            document.getElementById('add-manual').onclick = () => {
                const date = document.getElementById('manual-date').value;
                const drawNum = parseInt(document.getElementById('manual-draw').value);
                const numbersText = document.getElementById('manual-numbers').value;
                const additionalNum = parseInt(document.getElementById('manual-additional').value);
                
                // Validate inputs
                if (!date || !drawNum || !numbersText || !additionalNum) {
                    alert('Please fill in all fields');
                    return;
                }
                
                const numbers = numbersText.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n) && n >= 1 && n <= 49);
                
                if (numbers.length !== 6) {
                    alert('Please enter exactly 6 valid winning numbers (1-49)');
                    return;
                }
                
                if (additionalNum < 1 || additionalNum > 49) {
                    alert('Additional number must be between 1 and 49');
                    return;
                }
                
                // Check for duplicates
                const existingDates = totoData.map(item => item.Date);
                if (existingDates.includes(date)) {
                    alert('TOTO data for this date already exists');
                    return;
                }
                
                // Sort numbers
                numbers.sort((a, b) => a - b);
                
                // Create new entry
                const newEntry = {
                    "Date": date,
                    "Draw": drawNum,
                    "Number 1": numbers[0],
                    "Number 2": numbers[1],
                    "Number 3": numbers[2],
                    "Number 4": numbers[3],
                    "Number 5": numbers[4],
                    "Number 6": numbers[5],
                    "Additional Number": additionalNum
                };
                
                // Add to data
                totoData.unshift(newEntry);
                totoData.sort((a, b) => new Date(b.Date) - new Date(a.Date));
                
                // Update UI
                const statusIndicator = document.getElementById('status-indicator');
                const statusText = document.getElementById('status-text');
                
                statusIndicator.className = 'status-indicator success';
                statusText.textContent = 'Successfully added manual TOTO data!';
                statusIndicator.style.cursor = 'default';
                statusIndicator.onclick = null;
                
                document.getElementById('data-source').textContent = 'Source: Manual Entry (Real TOTO Data)';
                document.getElementById('last-updated').textContent = `Last updated: ${new Date().toLocaleString()}`;
                
                refreshAllDisplays();
                
                console.log('‚úÖ Successfully added manual TOTO data:', newEntry);
                
                document.body.removeChild(modal);
            };
            
            // Close on background click
            modal.onclick = (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            };
        }
        
        function generateRealisticNewData() {
            try {
                // Generate realistic new TOTO data based on historical patterns
                const newData = [];
                const today = new Date();
                
                // Get existing dates to avoid duplicates
                const existingDates = new Set(totoData.map(item => item.Date));
                console.log('Existing dates count:', existingDates.size);
                
                // Generate 1 new draw with guaranteed unique date
                console.log('Generating 1 new draw...');
                
                // Find a unique date by adding days to the most recent date
                let uniqueDate;
                let attempts = 0;
                do {
                    const baseDate = new Date(today);
                    baseDate.setDate(baseDate.getDate() + attempts); // Add days to ensure uniqueness
                    uniqueDate = baseDate.toISOString().split('T')[0];
                    attempts++;
                } while (existingDates.has(uniqueDate) && attempts < 365);
                
                console.log('Generated unique date:', uniqueDate);
                
                // Generate numbers based on historical frequency patterns
                const numbers = generateNumbersBasedOnFrequency();
                console.log('Generated numbers:', numbers);
                
                // Generate additional number (simple approach)
                let additionalNumber = Math.floor(Math.random() * 49) + 1;
                // If it's the same as any main number, just pick a different one
                if (numbers.includes(additionalNumber)) {
                    for (let j = 1; j <= 49; j++) {
                        if (!numbers.includes(j)) {
                            additionalNumber = j;
                            break;
                        }
                    }
                }
                
                const drawData = {
                    "Date": uniqueDate,
                    "Winning Number 1": numbers[0],
                    "2": numbers[1],
                    "3": numbers[2],
                    "4": numbers[3],
                    "5": numbers[4],
                    "6": numbers[5],
                    "Additional Number": additionalNumber
                };
                
                newData.push(drawData);
                console.log('Created draw data:', drawData);
                
                console.log('Final new data:', newData);
                return newData;
            } catch (error) {
                console.error('Error in generateRealisticNewData:', error);
                // Return a simple fallback draw with guaranteed unique timestamp
                const uniqueTimestamp = new Date().getTime();
                const fallbackDate = new Date(uniqueTimestamp).toISOString().split('T')[0];
                const fallbackData = [{
                    "Date": fallbackDate,
                    "Winning Number 1": 1,
                    "2": 2,
                    "3": 3,
                    "4": 4,
                    "5": 5,
                    "6": 6,
                    "Additional Number": 7
                }];
                console.log('Using fallback data:', fallbackData);
                return fallbackData;
            }
        }

        function generateNumbersBasedOnFrequency() {
            try {
                // Simple approach: mix of frequent and random numbers
                const numbers = [];
                
                // Get the most frequent numbers from existing data
                const frequency = {};
                for (let i = 1; i <= 49; i++) {
                    frequency[i] = 0;
                }
                
                // Count frequency of each number in existing data
                totoData.forEach(row => {
                    getWinningNumbers(row).forEach(num => {
                        if (num >= 1 && num <= 49) {
                            frequency[num] = (frequency[num] || 0) + 1;
                        }
                    });
                });
                
                // Get top 10 most frequent numbers
                const topFrequent = Object.entries(frequency)
                    .map(([number, freq]) => ({ number: parseInt(number), frequency: freq }))
                    .sort((a, b) => b.frequency - a.frequency)
                    .slice(0, 10)
                    .map(item => item.number);
                
                // Select 3 numbers from most frequent
                for (let i = 0; i < 3; i++) {
                    if (topFrequent.length > 0) {
                        const randomIndex = Math.floor(Math.random() * topFrequent.length);
                        const selectedNumber = topFrequent.splice(randomIndex, 1)[0];
                        numbers.push(selectedNumber);
                    }
                }
                
                // Fill remaining 3 with random numbers
                while (numbers.length < 6) {
                    const randomNum = Math.floor(Math.random() * 49) + 1;
                    if (!numbers.includes(randomNum)) {
                        numbers.push(randomNum);
                    }
                }
                
                // Sort the numbers
                numbers.sort((a, b) => a - b);
                return numbers;
            } catch (error) {
                console.error('Error in generateNumbersBasedOnFrequency:', error);
                // Fallback: return 6 random numbers
                const fallbackNumbers = [];
                while (fallbackNumbers.length < 6) {
                    const randomNum = Math.floor(Math.random() * 49) + 1;
                    if (!fallbackNumbers.includes(randomNum)) {
                        fallbackNumbers.push(randomNum);
                    }
                }
                fallbackNumbers.sort((a, b) => a - b);
                return fallbackNumbers;
            }
        }

        function mergeTotoData(existingData, newData) {
            try {
                console.log('Merging data...');
                console.log('Existing data length:', existingData.length);
                console.log('New data:', newData);
                
                // Create a map of existing dates for quick lookup
                const existingDates = new Set(existingData.map(item => item.Date));
                console.log('Existing dates:', Array.from(existingDates).slice(0, 5), '... (showing first 5)');
                
                // Filter out duplicates and add new data
                const uniqueNewData = newData.filter(item => {
                    const isUnique = !existingDates.has(item.Date);
                    console.log(`Date ${item.Date} is ${isUnique ? 'unique' : 'duplicate'}`);
                    return isUnique;
                });
                
                console.log('Unique new data:', uniqueNewData);
                console.log('Unique new data length:', uniqueNewData.length);
                
                // Combine and sort by date (newest first)
                const combinedData = [...existingData, ...uniqueNewData];
                combinedData.sort((a, b) => new Date(b.Date) - new Date(a.Date));
                
                console.log('Combined data length:', combinedData.length);
                return combinedData;
            } catch (error) {
                console.error('Error in mergeTotoData:', error);
                return existingData; // Return original data if merge fails
            }
        }

        function refreshAllDisplays() {
            // Get latest winning numbers for highlighting
            const latestNumbers = getLatestWinningNumbers(totoData);
            
            // Update all displays
            updateSummaryCards(totoData);
            const predictions = generatePredictions(totoData);
            renderPredictions(predictions, latestNumbers);
            renderStatistics(totoData, latestNumbers, predictions);
            renderDataTable(totoData, latestNumbers, predictions);
            
            // Update chart if it's currently visible
            const chartsTab = document.getElementById('charts-tab');
            if (!chartsTab.classList.contains('hidden')) {
                renderChart(totoData, latestNumbers, predictions);
            }
        }

        // Analysis functions
        function calculateFrequency(data, position) {
            const freq = {};
            data.forEach(row => {
                const num = row[position];
                freq[num] = (freq[num] || 0) + 1;
            });
            return Object.entries(freq).map(([number, frequency]) => ({
                number: parseInt(number),
                frequency,
                percentage: (frequency / data.length) * 100
            })).sort((a, b) => b.frequency - a.frequency);
        }

        function generatePredictions(data) {
            const predictions = [];
            
            // Calculate frequency across ALL winning numbers (positions 1-6)
            const allNumbers = {};
            
            // Initialize all numbers 1-49 with 0 frequency
            for (let i = 1; i <= 49; i++) {
                allNumbers[i] = 0;
            }
            
            data.forEach(row => {
                // Count all 6 winning numbers from each draw
                getWinningNumbers(row).forEach(num => {
                    // Convert to number and check if valid
                    const number = parseInt(num);
                    if (!isNaN(number) && number >= 1 && number <= 49) {
                        allNumbers[number] = (allNumbers[number] || 0) + 1;
                    }
                });
            });
            
            // Convert to array and sort by frequency
            const overallFreq = Object.entries(allNumbers)
                .map(([number, frequency]) => ({
                    number: parseInt(number),
                    frequency,
                    percentage: (frequency / (data.length * 6)) * 100
                }))
                .sort((a, b) => b.frequency - a.frequency);
            
            // Method 1: Most Frequent (2 sets)
            const mostFrequent = overallFreq.slice(0, 6).map(f => f.number).sort((a, b) => a - b);
            predictions.push({
                method: 'Most Frequent Numbers',
                numbers: mostFrequent,
                confidence: 0.25,
                reasoning: 'Based on historical frequency analysis across all positions'
            });
            
            // Most Frequent Set 2 (with slight variation)
            const mostFrequentSet2 = overallFreq.slice(0, 8).map(f => f.number);
            const shuffledMostFrequent = [...mostFrequentSet2].sort(() => Math.random() - 0.5).slice(0, 6).sort((a, b) => a - b);
            predictions.push({
                method: 'Most Frequent Numbers (Set 2)',
                numbers: shuffledMostFrequent,
                confidence: 0.22,
                reasoning: 'Alternative selection from top 8 most frequent numbers'
            });

            // Method 2: Position-based (2 sets)
            const positions = ['Winning Number 1', '2', '3', '4', '5', '6'];
            const positionNumbers = [];
            positions.forEach(pos => {
                const freq = calculateFrequency(data, pos);
                positionNumbers.push(freq[0].number);
            });
            predictions.push({
                method: 'Position-Based Analysis',
                numbers: positionNumbers.sort((a, b) => a - b),
                confidence: 0.30,
                reasoning: 'Selecting most frequent number for each position (1-6)'
            });
            
            // Position-based Set 2 (using second most frequent for each position)
            const positionNumbersSet2 = [];
            positions.forEach(pos => {
                const freq = calculateFrequency(data, pos);
                if (freq.length > 1) {
                    positionNumbersSet2.push(freq[1].number);
                } else {
                    positionNumbersSet2.push(freq[0].number);
                }
            });
            predictions.push({
                method: 'Position-Based Analysis (Set 2)',
                numbers: positionNumbersSet2.sort((a, b) => a - b),
                confidence: 0.28,
                reasoning: 'Selecting second most frequent number for each position (1-6)'
            });

            // Method 3: Hot numbers (2 sets)
            const recentDraws = data.slice(0, 5);
            const recentNumbers = {};
            recentDraws.forEach(row => {
                getWinningNumbers(row).forEach(num => {
                    recentNumbers[num] = (recentNumbers[num] || 0) + 1;
                });
            });
            
            // Hot Numbers Set 1
            const hotNumbersEntries = Object.entries(recentNumbers)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const hotNumbers = [];
            for (let i = 0; i < 6; i++) {
                if (hotNumbersEntries.length > 0) {
                    const randomIndex = Math.floor(Math.random() * Math.min(5, hotNumbersEntries.length));
                    const selected = hotNumbersEntries.splice(randomIndex, 1)[0];
                    hotNumbers.push(parseInt(selected[0]));
                }
            }
            hotNumbers.sort((a, b) => a - b);
            predictions.push({
                method: 'Hot Numbers',
                numbers: hotNumbers,
                confidence: 0.20,
                reasoning: 'Based on numbers appearing frequently in recent draws across all positions'
            });
            
            // Hot Numbers Set 2 (different random selection)
            const hotNumbersEntries2 = Object.entries(recentNumbers)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 12);
            
            const hotNumbers2 = [];
            for (let i = 0; i < 6; i++) {
                if (hotNumbersEntries2.length > 0) {
                    const randomIndex = Math.floor(Math.random() * Math.min(6, hotNumbersEntries2.length));
                    const selected = hotNumbersEntries2.splice(randomIndex, 1)[0];
                    hotNumbers2.push(parseInt(selected[0]));
                }
            }
            hotNumbers2.sort((a, b) => a - b);
            predictions.push({
                method: 'Hot Numbers (Set 2)',
                numbers: hotNumbers2,
                confidence: 0.18,
                reasoning: 'Alternative selection from recent hot numbers with different randomization'
            });

            // Method 4: Cold numbers (2 sets)
            const coldNumbers = overallFreq.slice(-6).map(f => f.number).sort((a, b) => a - b);
            predictions.push({
                method: 'Cold Numbers',
                numbers: coldNumbers,
                confidence: 0.15,
                reasoning: 'Based on numbers that have appeared least frequently across all positions'
            });
            
            // Cold Numbers Set 2 (slightly different range)
            const coldNumbers2 = overallFreq.slice(-8).map(f => f.number);
            const shuffledColdNumbers = [...coldNumbers2].sort(() => Math.random() - 0.5).slice(0, 6).sort((a, b) => a - b);
            predictions.push({
                method: 'Cold Numbers (Set 2)',
                numbers: shuffledColdNumbers,
                confidence: 0.13,
                reasoning: 'Alternative selection from bottom 8 least frequent numbers'
            });

            // Method 5: Balanced approach (2 sets)
            const mostFrequentPool = mostFrequent.slice(0, 5);
            const coldNumbersPool = coldNumbers.slice(0, 5);
            
            // Balanced Set 1
            const balanced = [];
            for (let i = 0; i < 3; i++) {
                if (mostFrequentPool.length > 0) {
                    const randomIndex = Math.floor(Math.random() * mostFrequentPool.length);
                    const selected = mostFrequentPool.splice(randomIndex, 1)[0];
                    balanced.push(selected);
                }
            }
            for (let i = 0; i < 3; i++) {
                if (coldNumbersPool.length > 0) {
                    const randomIndex = Math.floor(Math.random() * coldNumbersPool.length);
                    const selected = coldNumbersPool.splice(randomIndex, 1)[0];
                    balanced.push(selected);
                }
            }
            balanced.sort((a, b) => a - b);
            predictions.push({
                method: 'Balanced Approach',
                numbers: balanced,
                confidence: 0.35,
                reasoning: 'Combination of most frequent and least frequent numbers across all positions'
            });
            
            // Balanced Set 2 (different ratio)
            const mostFrequentPool2 = overallFreq.slice(0, 6).map(f => f.number);
            const coldNumbersPool2 = overallFreq.slice(-6).map(f => f.number);
            
            const balanced2 = [];
            // 4 from most frequent, 2 from least frequent
            for (let i = 0; i < 4; i++) {
                if (mostFrequentPool2.length > 0) {
                    const randomIndex = Math.floor(Math.random() * mostFrequentPool2.length);
                    const selected = mostFrequentPool2.splice(randomIndex, 1)[0];
                    balanced2.push(selected);
                }
            }
            for (let i = 0; i < 2; i++) {
                if (coldNumbersPool2.length > 0) {
                    const randomIndex = Math.floor(Math.random() * coldNumbersPool2.length);
                    const selected = coldNumbersPool2.splice(randomIndex, 1)[0];
                    balanced2.push(selected);
                }
            }
            balanced2.sort((a, b) => a - b);
            predictions.push({
                method: 'Balanced Approach (Set 2)',
                numbers: balanced2,
                confidence: 0.32,
                reasoning: 'Alternative balanced approach: 4 frequent + 2 cold numbers'
            });

            // Method 6: Chronological Trend Analysis (Bottom-Up)
            const chronoTrendNumbers = [];
            
            // Sort data chronologically (oldest first) for trend analysis
            const chronoData = [...data].sort((a, b) => new Date(a.Date) - new Date(b.Date));
            const trendWindow = 10; // Analyze trends in windows of 10 draws
            
            // Track number appearance trends over time
            const numberTrends = {};
            for (let i = 1; i <= 49; i++) {
                numberTrends[i] = { appearing: 0, disappearing: 0, trend: 0 };
            }
            
            // Analyze trends in sliding windows
            for (let windowStart = 0; windowStart <= chronoData.length - trendWindow * 2; windowStart += trendWindow) {
                const earlyWindow = chronoData.slice(windowStart, windowStart + trendWindow);
                const lateWindow = chronoData.slice(windowStart + trendWindow, windowStart + trendWindow * 2);
                
                // Count appearances in each window
                const earlyCount = {};
                const lateCount = {};
                
                for (let i = 1; i <= 49; i++) {
                    earlyCount[i] = 0;
                    lateCount[i] = 0;
                }
                
                earlyWindow.forEach(row => {
                    [row['Winning Number 1'], row['2'], row['3'], row['4'], row['5'], row['6']].forEach(num => {
                        const number = parseInt(num);
                        if (!isNaN(number) && number >= 1 && number <= 49) {
                            earlyCount[number]++;
                        }
                    });
                });
                
                lateWindow.forEach(row => {
                    [row['Winning Number 1'], row['2'], row['3'], row['4'], row['5'], row['6']].forEach(num => {
                        const number = parseInt(num);
                        if (!isNaN(number) && number >= 1 && number <= 49) {
                            lateCount[number]++;
                        }
                    });
                });
                
                // Calculate trend for each number
                for (let i = 1; i <= 49; i++) {
                    const trendValue = lateCount[i] - earlyCount[i];
                    numberTrends[i].trend += trendValue;
                    if (trendValue > 0) numberTrends[i].appearing++;
                    if (trendValue < 0) numberTrends[i].disappearing++;
                }
            }
            
            // Select numbers with strongest positive trends
            const trendingUp = Object.entries(numberTrends)
                .map(([num, trend]) => ({
                    number: parseInt(num),
                    trendScore: trend.trend + (trend.appearing * 0.5) - (trend.disappearing * 0.3),
                    overallFreq: allNumbers[parseInt(num)] || 0
                }))
                .sort((a, b) => b.trendScore - a.trendScore)
                .slice(0, 8); // Get top 8 trending numbers
            
            // Select 6 numbers combining trend and frequency
            for (let i = 0; i < 6 && i < trendingUp.length; i++) {
                chronoTrendNumbers.push(trendingUp[i].number);
            }
            
            // Fill remaining slots with recent frequency if needed
            while (chronoTrendNumbers.length < 6) {
                const recentFreq = calculateFrequency(data.slice(0, 5), 'Winning Number 1');
                for (const freq of recentFreq) {
                    if (!chronoTrendNumbers.includes(freq.number) && chronoTrendNumbers.length < 6) {
                        chronoTrendNumbers.push(freq.number);
                    }
                }
            }
            
            chronoTrendNumbers.sort((a, b) => a - b);
            predictions.push({
                method: 'Chronological Trend Analysis',
                numbers: chronoTrendNumbers.slice(0, 6),
                confidence: 0.33,
                reasoning: 'Bottom-up chronological analysis of number appearance trends over time'
            });

            // Method 7: Cyclical Pattern Analysis
            const cyclicalNumbers = [];
            
            // Analyze cyclical patterns in the complete dataset (oldest to newest)
            const fullChronoData = [...data].sort((a, b) => new Date(a.Date) - new Date(b.Date));
            const cycleLength = 7; // Weekly cycle analysis
            
            // Track number appearances by cycle position
            const cyclePatterns = {};
            for (let i = 1; i <= 49; i++) {
                cyclePatterns[i] = new Array(cycleLength).fill(0);
            }
            
            fullChronoData.forEach((row, index) => {
                const cyclePosition = index % cycleLength;
                [row['Winning Number 1'], row['2'], row['3'], row['4'], row['5'], row['6']].forEach(num => {
                    const number = parseInt(num);
                    if (!isNaN(number) && number >= 1 && number <= 49) {
                        cyclePatterns[number][cyclePosition]++;
                    }
                });
            });
            
            // Determine current cycle position based on latest data
            const currentCyclePos = (fullChronoData.length - 1) % cycleLength;
            const nextCyclePos = (currentCyclePos + 1) % cycleLength;
            
            // Find numbers that perform well at the predicted next cycle position
            const cyclicalScores = Object.entries(cyclePatterns)
                .map(([num, cycles]) => ({
                    number: parseInt(num),
                    cyclicalScore: cycles[nextCyclePos],
                    consistency: cycles.reduce((sum, count) => sum + (count > 0 ? 1 : 0), 0), // How many cycle positions it appears in
                    totalAppearances: cycles.reduce((sum, count) => sum + count, 0)
                }))
                .filter(item => item.cyclicalScore > 0) // Only numbers that appear in target cycle position
                .sort((a, b) => {
                    // Primary sort: cyclical score for next position
                    // Secondary sort: consistency across cycles
                    if (b.cyclicalScore !== a.cyclicalScore) {
                        return b.cyclicalScore - a.cyclicalScore;
                    }
                    return b.consistency - a.consistency;
                });
            
            // Select top 6 cyclical performers
            for (let i = 0; i < 6 && i < cyclicalScores.length; i++) {
                cyclicalNumbers.push(cyclicalScores[i].number);
            }
            
            // Fill remaining slots with numbers showing strong cyclical patterns
            if (cyclicalNumbers.length < 6) {
                const backupNumbers = cyclicalScores.slice(6, 15).map(item => item.number);
                while (cyclicalNumbers.length < 6 && backupNumbers.length > 0) {
                    const randomIndex = Math.floor(Math.random() * backupNumbers.length);
                    const selected = backupNumbers.splice(randomIndex, 1)[0];
                    if (!cyclicalNumbers.includes(selected)) {
                        cyclicalNumbers.push(selected);
                    }
                }
            }
            
            cyclicalNumbers.sort((a, b) => a - b);
            predictions.push({
                method: 'Cyclical Pattern Analysis',
                numbers: cyclicalNumbers.slice(0, 6),
                confidence: 0.31,
                reasoning: `Cyclical pattern analysis (7-day cycle, next position: ${nextCyclePos + 1})`
            });

            return predictions;
        }

        function updateSummaryCards(data) {
            const totalDraws = data.length;
            const dates = data.map(row => new Date(row.Date)).sort((a, b) => a.getTime() - b.getTime());
            
            // Calculate frequency across ALL winning numbers (positions 1-6)
            const allNumbers = {};
            
            // Initialize all numbers 1-49 with 0 frequency
            for (let i = 1; i <= 49; i++) {
                allNumbers[i] = 0;
            }
            
            data.forEach(row => {
                // Count all 6 winning numbers from each draw
                getWinningNumbers(row).forEach(num => {
                    // Convert to number and check if valid
                    const number = parseInt(num);
                    if (!isNaN(number) && number >= 1 && number <= 49) {
                        allNumbers[number] = (allNumbers[number] || 0) + 1;
                    }
                });
            });
            
            // Convert to array and sort by frequency
            const overallFreq = Object.entries(allNumbers)
                .map(([number, frequency]) => ({
                    number: parseInt(number),
                    frequency,
                    percentage: (frequency / (data.length * 6)) * 100
                }))
                .sort((a, b) => b.frequency - a.frequency);
            
            document.getElementById('total-draws').textContent = totalDraws;
            document.getElementById('date-range').textContent = 
                `${dates[0].toLocaleDateString()} to ${dates[dates.length - 1].toLocaleDateString()}`;
            
            document.getElementById('most-frequent').textContent = overallFreq[0].number;
            document.getElementById('most-frequent-details').textContent = 
                `${overallFreq[0].frequency} times (${overallFreq[0].percentage.toFixed(1)}%)`;
            
            document.getElementById('least-frequent').textContent = overallFreq[overallFreq.length - 1].number;
            document.getElementById('least-frequent-details').textContent = 
                `${overallFreq[overallFreq.length - 1].frequency} times (${overallFreq[overallFreq.length - 1].percentage.toFixed(1)}%)`;
        }

        function renderPredictions(predictions, latestNumbers = []) {
            const container = document.getElementById('predictions-container');
            container.innerHTML = predictions.map(pred => `
                <div class="bg-gray-50 rounded-lg p-6 card-hover">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="font-semibold text-lg">${pred.method}</h3>
                        <span class="text-sm text-gray-500">${(pred.confidence * 100).toFixed(0)}% confidence</span>
                    </div>
                    <p class="text-sm text-gray-600 mb-4">${pred.reasoning}</p>
                    <div class="flex flex-wrap gap-2 mb-4">
                        ${pred.numbers.map(num => {
                            const isLatest = latestNumbers.includes(num);
                            if (isLatest) {
                                return `<span class="badge" style="background-color: #dc2626; color: white; border-color: #b91c1c; box-shadow: 0 0 8px rgba(220, 38, 38, 0.5);">${num}</span>`;
                            } else {
                                return `<span class="badge primary">${num}</span>`;
                            }
                        }).join('')}
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${pred.confidence * 100}%"></div>
                    </div>
                </div>
            `).join('');
        }

        // Color scheme for different prediction methods
        const predictionColors = {
            'Most Frequent Numbers': { bg: '#0891b2', text: 'white', border: '#0e7490' }, // Teal/Cyan
            'Most Frequent Numbers (Set 2)': { bg: '#0e7490', text: 'white', border: '#155e75' }, // Darker Teal
            'Position-Based Analysis': { bg: '#10b981', text: 'white', border: '#059669' }, // Green
            'Position-Based Analysis (Set 2)': { bg: '#059669', text: 'white', border: '#047857' }, // Darker Green
            'Hot Numbers': { bg: '#f59e0b', text: 'white', border: '#d97706' }, // Orange
            'Hot Numbers (Set 2)': { bg: '#d97706', text: 'white', border: '#b45309' }, // Darker Orange
            'Cold Numbers': { bg: '#8b5cf6', text: 'white', border: '#7c3aed' }, // Purple
            'Cold Numbers (Set 2)': { bg: '#7c3aed', text: 'white', border: '#6d28d9' }, // Darker Purple
            'Balanced Approach': { bg: '#ef4444', text: 'white', border: '#dc2626' }, // Red
            'Balanced Approach (Set 2)': { bg: '#dc2626', text: 'white', border: '#b91c1c' }, // Darker Red
            'Chronological Trend Analysis': { bg: '#06b6d4', text: 'white', border: '#0891b2' }, // Sky Blue
            'Cyclical Pattern Analysis': { bg: '#84cc16', text: 'white', border: '#65a30d' } // Lime Green
        };

        // Function to get color for a number based on predictions
        function getNumberColor(number, predictions, latestNumbers = []) {
            // First check if it's a latest winning number (highest priority)
            if (latestNumbers.includes(number)) {
                return { bg: '#dc2626', text: 'white', border: '#b91c1c', shadow: '0 0 8px rgba(220, 38, 38, 0.5)' }; // Bright red for latest with glow
            }
            
            // Check if number appears in any prediction
            for (const pred of predictions) {
                if (pred.numbers.includes(number)) {
                    return predictionColors[pred.method] || { bg: '#6b7280', text: 'white', border: '#4b5563' };
                }
            }
            
            // Default color for numbers not in predictions - dark black text for better visibility
            return { bg: '#f3f4f6', text: '#000000', border: '#d1d5db' };
        }

        function renderStatistics(data, latestNumbers = [], predictions = []) {
            // Calculate frequency across ALL winning numbers (positions 1-6)
            const allNumbers = {};
            
            // Initialize all numbers 1-49 with 0 frequency
            for (let i = 1; i <= 49; i++) {
                allNumbers[i] = 0;
            }
            
            data.forEach(row => {
                // Count all 6 winning numbers from each draw
                getWinningNumbers(row).forEach(num => {
                    // Convert to number and check if valid
                    const number = parseInt(num);
                    if (!isNaN(number) && number >= 1 && number <= 49) {
                        allNumbers[number] = (allNumbers[number] || 0) + 1;
                    }
                });
            });
            
            // Convert to array and sort by frequency
            const overallFreq = Object.entries(allNumbers)
                .map(([number, frequency]) => ({
                    number: parseInt(number),
                    frequency,
                    percentage: (frequency / (data.length * 6)) * 100
                }))
                .sort((a, b) => b.frequency - a.frequency);
            
            // Create array with ALL numbers 1-49, including zero frequencies
            const allNumbersArray = [];
            for (let i = 1; i <= 49; i++) {
                const freq = allNumbers[i] || 0;
                allNumbersArray.push({
                    number: i,
                    frequency: freq,
                    percentage: (freq / (data.length * 6)) * 100
                });
            }
            
            // Sort by frequency (highest first)
            const sortedByFrequency = allNumbersArray.sort((a, b) => b.frequency - a.frequency);
            
            // Show ALL numbers in statistics (not just top 15 and bottom 15)
            const statisticsContainer = document.getElementById('statistics-tab'); // Corrected ID
            statisticsContainer.innerHTML = `
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-white rounded-lg p-6 card-hover">
                        <h3 class="text-lg font-semibold mb-4 text-gray-900">All Numbers by Frequency (1-49)</h3>
                        <div class="space-y-2 max-h-96 overflow-y-auto">
                            ${sortedByFrequency.map(item => {
                                const color = getNumberColor(item.number, predictions, latestNumbers);
                                const isLatest = latestNumbers.includes(item.number);
                                return `
                                    <div class="flex items-center justify-between p-2 rounded ${isLatest ? 'bg-red-50 border border-red-200' : 'hover:bg-gray-50'}">
                                        <div class="flex items-center gap-3">
                                            <span class="badge" style="background-color: ${color.bg}; color: ${color.text}; border-color: ${color.border}; ${color.shadow ? `box-shadow: ${color.shadow};` : ''}">${item.number}</span>
                                            <span class="text-sm">${item.frequency} times</span>
                                        </div>
                                        <span class="text-xs text-gray-500">${item.percentage.toFixed(1)}%</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    
                    <div class="bg-white rounded-lg p-6 card-hover">
                        <h3 class="text-lg font-semibold mb-4 text-gray-900">Prediction Categories Legend</h3>
                        <div class="space-y-3">
                            ${Object.entries(predictionColors).map(([method, color]) => `
                                <div class="flex items-center gap-3">
                                    <span class="badge" style="background-color: ${color.bg}; color: ${color.text}; border-color: ${color.border}; ${color.shadow ? `box-shadow: ${color.shadow};` : ''}">Sample</span>
                                    <span class="text-sm text-gray-700">${method}</span>
                                </div>
                            `).join('')}
                            <div class="flex items-center gap-3 mt-4 pt-3 border-t">
                                <span class="badge" style="background-color: #dc2626; color: white; border-color: #b91c1c; box-shadow: 0 0 8px rgba(220, 38, 38, 0.5);">Sample</span>
                                <span class="text-sm text-gray-700 font-semibold">Latest Winning Numbers (Always Red)</span>
                            </div>
                            <div class="flex items-center gap-3">
                                <span class="badge bg-gray-100 text-gray-700 border-gray-300">Sample</span>
                                <span class="text-sm text-gray-700">Not in Predictions</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderDataTable(data, latestNumbers = [], predictions = []) {
            const tableBody = document.getElementById('data-table');
            const dataCount = document.getElementById('data-count');
            
            // Update the count display
            dataCount.textContent = `${data.length} draws from ${data[data.length - 1]?.Date || 'N/A'} to ${data[0]?.Date || 'N/A'}`;
            
            tableBody.innerHTML = data.map(row => {
                const winningNumbers = getWinningNumbers(row);
                const additionalNumber = row['Additional Number'];
                
                // Check if this is the latest draw
                const isLatestDraw = data.indexOf(row) === 0; // First row is latest
                
                return `
                    <tr class="border-b hover:bg-gray-50 ${isLatestDraw ? 'bg-red-50 border-red-200' : ''}">
                        <td class="p-2 font-medium">
                            ${row.Date}
                            ${isLatestDraw ? '<span class="ml-2 px-2 py-1 text-xs bg-red-100 text-red-800 rounded-full font-semibold">LATEST</span>' : ''}
                        </td>
                        <td class="p-2">
                            <div class="flex flex-wrap gap-1">
                                ${winningNumbers.map(num => {
                                    const color = getNumberColor(num, predictions, latestNumbers);
                                    const isLatest = latestNumbers.includes(num);
                                    return `<span class="badge" style="background-color: ${color.bg}; color: ${color.text}; border-color: ${color.border}; ${color.shadow ? `box-shadow: ${color.shadow};` : ''}">${num}</span>`;
                                }).join('')}
                            </div>
                        </td>
                        <td class="p-2">
                            <span class="badge secondary">${additionalNumber}</span>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        // Generate prediction method checkboxes
        function generatePredictionCheckboxes(predictions = []) {
            const checkboxContainer = document.getElementById('prediction-checkboxes');
            if (!checkboxContainer) return;

            checkboxContainer.innerHTML = '';
            
            predictions.forEach((prediction, index) => {
                const checkboxId = `prediction-${index}`;
                const color = predictionColors[prediction.method] || { bg: '#6b7280' };
                
                const checkboxHtml = `
                    <div class="flex items-center space-x-2">
                        <input type="checkbox" 
                               id="${checkboxId}" 
                               class="prediction-checkbox rounded text-blue-600 focus:ring-blue-500" 
                               data-method="${prediction.method}"
                               onchange="updateChartDisplay()">
                        <label for="${checkboxId}" class="text-sm cursor-pointer flex items-center space-x-2">
                            <span class="w-4 h-4 rounded" style="background-color: ${color.bg}; border: 1px solid ${color.border};"></span>
                            <span class="text-gray-700">${prediction.method}</span>
                        </label>
                    </div>
                `;
                checkboxContainer.innerHTML += checkboxHtml;
            });
        }

        // Get selected prediction methods
        function getSelectedPredictions(allPredictions = []) {
            const selectedMethods = Array.from(document.querySelectorAll('.prediction-checkbox:checked'))
                .map(checkbox => checkbox.dataset.method);
            
            return allPredictions.filter(pred => selectedMethods.includes(pred.method));
        }

        // Update chart display based on selections
        function updateChartDisplay() {
            const chartsTab = document.getElementById('charts-tab');
            if (!chartsTab.classList.contains('hidden')) {
                const allPredictions = generatePredictions(totoData);
                const selectedPredictions = getSelectedPredictions(allPredictions);
                const latestNumbers = getLatestWinningNumbers(totoData);
                renderChart(totoData, latestNumbers, selectedPredictions);
            }
        }

        function renderChart(data, latestNumbers = [], predictions = []) {
            const canvas = document.getElementById('frequencyChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to fill the container and make it large
            const container = canvas.parentElement;
            const width = Math.max(1600, container.clientWidth - 40); // Increased minimum width to 1600px for better number spacing
            const height = Math.max(800, window.innerHeight - 300); // At least 800px tall, or fill most of viewport
            canvas.width = width;
            canvas.height = height;
            
            // Calculate frequency across ALL winning numbers (positions 1-6)
            const allNumbers = {};
            
            // Initialize all numbers 1-49 with 0 frequency
            for (let i = 1; i <= 49; i++) {
                allNumbers[i] = 0;
            }
            
            data.forEach(row => {
                // Count all 6 winning numbers from each draw
                getWinningNumbers(row).forEach(num => {
                    // Convert to number and check if valid
                    const number = parseInt(num);
                    if (!isNaN(number) && number >= 1 && number <= 49) {
                        allNumbers[number] = (allNumbers[number] || 0) + 1;
                    }
                });
            });
            
            // Convert to array and sort by frequency
            const overallFreq = Object.entries(allNumbers)
                .map(([number, frequency]) => ({
                    number: parseInt(number),
                    frequency,
                    percentage: (frequency / (data.length * 6)) * 100
                }))
                .sort((a, b) => b.frequency - a.frequency);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Chart dimensions with larger padding for better visibility
            const padding = 60;
            const bottomPadding = 80; // Increased bottom padding for x-axis labels
            const chartWidth = width - 2 * padding;
            const chartHeight = height - padding - bottomPadding;
            
            // Create array with ALL numbers 1-49, including zero frequencies
            const allNumbersArray = [];
            for (let i = 1; i <= 49; i++) {
                const freq = allNumbers[i] || 0;
                allNumbersArray.push({
                    number: i,
                    frequency: freq,
                    percentage: (freq / (data.length * 6)) * 100
                });
            }
            
            // Debug: Log to ensure all 49 numbers are present
            console.log('Total numbers in array:', allNumbersArray.length);
            console.log('Numbers range:', allNumbersArray[0]?.number, 'to', allNumbersArray[allNumbersArray.length-1]?.number);
            
            const maxFreq = Math.max(...allNumbersArray.map(item => item.frequency));
            
            // Draw title
            ctx.fillStyle = '#374151';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Number Frequency Distribution (1-49)', width / 2, 30);
            
            // Draw subtitle
            ctx.fillStyle = '#6b7280';
            ctx.font = '14px Arial';
            ctx.fillText(`Based on ${data.length} draws with 6 numbers each`, width / 2, 50);
            
            // Draw legend
            ctx.fillStyle = '#374151';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Legend:', 10, 80);
            
            // Draw prediction method colors in legend
            let legendY = 100;
            Object.entries(predictionColors).forEach(([method, color], index) => {
                if (index < 5) { // Show first 5 methods to avoid clutter
                    ctx.fillStyle = color.bg;
                    ctx.fillRect(10, legendY, 20, 10);
                    ctx.fillStyle = '#374151';
                    ctx.fillText(method, 35, legendY + 8);
                    legendY += 20;
                }
            });
            
            // Red bar legend for latest numbers
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(10, legendY, 20, 10);
            ctx.fillStyle = '#374151';
            ctx.fillText('Latest winning numbers', 35, legendY + 8);
            legendY += 20;
            
            // Gray bar legend for regular numbers
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(10, legendY, 20, 10);
            ctx.fillStyle = '#374151';
            ctx.fillText('Historical numbers', 35, legendY + 8);
            
            // Draw bars for all 49 numbers
            const barWidth = chartWidth / 49; // 49 numbers total
            const barSpacing = 2;
            const actualBarWidth = barWidth - barSpacing;
            
            allNumbersArray.forEach((item, index) => {
                const x = padding + index * barWidth;
                const barHeight = maxFreq > 0 ? (item.frequency / maxFreq) * chartHeight : 0;
                const y = height - bottomPadding - barHeight;
                
                // Check if this number is in the latest winning numbers
                const isLatestNumber = latestNumbers.includes(item.number);
                
                // Get color for this number based on predictions
                const color = getNumberColor(item.number, predictions, latestNumbers);
                
                // Draw bar (even if height is 0, it will show as a thin line)
                if (item.frequency > 0) {
                    if (isLatestNumber) {
                        // Red gradient for latest winning numbers (highest priority)
                        const gradient = ctx.createLinearGradient(x, y, x, height - bottomPadding);
                        gradient.addColorStop(0, '#ef4444');
                        gradient.addColorStop(1, '#dc2626');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(x, y, actualBarWidth, barHeight);
                        
                        // Draw red border
                        ctx.strokeStyle = '#b91c1c';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, actualBarWidth, barHeight);
                    } else if (predictions.some(pred => pred.numbers.includes(item.number))) {
                        // Use prediction color for numbers in predictions
                        const gradient = ctx.createLinearGradient(x, y, x, height - bottomPadding);
                        gradient.addColorStop(0, color.bg);
                        gradient.addColorStop(1, color.border);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(x, y, actualBarWidth, barHeight);
                        
                        // Draw border
                        ctx.strokeStyle = color.border;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x, y, actualBarWidth, barHeight);
                    } else {
                        // Blue gradient for other numbers
                        const gradient = ctx.createLinearGradient(x, y, x, height - bottomPadding);
                        gradient.addColorStop(0, '#3b82f6');
                        gradient.addColorStop(1, '#1d4ed8');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(x, y, actualBarWidth, barHeight);
                        
                        // Draw blue border
                        ctx.strokeStyle = '#1e40af';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x, y, actualBarWidth, barHeight);
                    }
                } else {
                    if (isLatestNumber) {
                        // Red line for latest winning numbers with zero frequency
                        ctx.fillStyle = '#fca5a5';
                        ctx.fillRect(x, height - bottomPadding - 2, actualBarWidth, 2);
                    } else if (predictions.some(pred => pred.numbers.includes(item.number))) {
                        // Use prediction color for zero-frequency prediction numbers
                        ctx.fillStyle = color.bg;
                        ctx.fillRect(x, height - bottomPadding - 2, actualBarWidth, 2);
                    } else {
                        // Gray line for other zero frequency numbers
                        ctx.fillStyle = '#e5e7eb';
                        ctx.fillRect(x, height - bottomPadding - 1, actualBarWidth, 1);
                    }
                }
                
                // Draw number label (clean text only)
                ctx.fillStyle = isLatestNumber ? '#dc2626' : (predictions.some(pred => pred.numbers.includes(item.number)) ? color.text : '#000000');
                ctx.font = 'bold 11px Arial'; // Slightly larger font since no background interference
                ctx.textAlign = 'center';
                ctx.fillText(item.number.toString(), x + actualBarWidth / 2, height - bottomPadding + 20);
                
                // Draw frequency label (only for non-zero frequencies to avoid clutter)
                if (item.frequency > 0) {
                    ctx.fillStyle = '#6b7280';
                    ctx.font = 'bold 11px Arial'; // Made frequency labels bold too
                    ctx.fillText(item.frequency.toString(), x + actualBarWidth / 2, y - 8);
                }
            });
            
            // Draw axes
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(padding, height - bottomPadding);
            ctx.lineTo(width - padding, height - bottomPadding);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - bottomPadding);
            ctx.stroke();
            
            // Y-axis labels
            ctx.fillStyle = '#6b7280';
            ctx.font = '14px Arial';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const y = height - bottomPadding - (i / 5) * chartHeight;
                const value = Math.round((i / 5) * maxFreq);
                ctx.fillText(value.toString(), padding - 10, y + 5);
            }
            
            // Draw horizontal grid lines for better readability
            ctx.strokeStyle = '#f3f4f6';
            ctx.lineWidth = 1;
            for (let i = 1; i < 5; i++) {
                const y = height - bottomPadding - (i / 5) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // Draw vertical grid lines every 5 numbers for better reference
            ctx.strokeStyle = '#f9fafb';
            ctx.lineWidth = 1;
            for (let i = 5; i < 49; i += 5) {
                const x = padding + i * barWidth;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - bottomPadding);
                ctx.stroke();
            }
            
            // Debug: Verify all numbers were rendered
            console.log('Chart rendering complete. All 49 numbers should be visible on x-axis.');
            console.log('Chart width:', width, 'Chart height:', height);
            console.log('Bar width:', barWidth, 'Total bars drawn:', allNumbersArray.length);
        }

        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.add('hidden');
            });
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName + '-tab').classList.remove('hidden');
            
            // Add active class to clicked button
            event.target.classList.add('active');
            
            // Render chart if charts tab is selected
            if (tabName === 'charts') {
                setTimeout(() => {
                    const latestNumbers = getLatestWinningNumbers(totoData);
                    const allPredictions = generatePredictions(totoData);
                    
                    // Generate checkboxes for prediction methods
                    generatePredictionCheckboxes(allPredictions);
                    
                    // Initially render chart with no predictions selected (only latest numbers in red)
                    renderChart(totoData, latestNumbers, []);
                }, 100);
            }
        }

        // Debug function to check for missing numbers
        function debugMissingNumbers(data) {
            const allNumbers = {};
            
            // Initialize all numbers 1-49 with 0 frequency
            for (let i = 1; i <= 49; i++) {
                allNumbers[i] = 0;
            }
            
            console.log('=== DEBUGGING NUMBER 3 ===');
            console.log('Looking for number 3 in data...');
            
            data.forEach((row, index) => {
                const numbers = getWinningNumbers(row);
                console.log(`Row ${index + 1}:`, numbers);
                
                numbers.forEach(num => {
                    // Convert to number and check if valid
                    const number = parseInt(num);
                    if (!isNaN(number) && number >= 1 && number <= 49) {
                        allNumbers[number] = (allNumbers[number] || 0) + 1;
                        if (number === 3) {
                            console.log(`Found number 3 in row ${index + 1}, total count now: ${allNumbers[3]}`);
                        }
                    }
                });
            });
            
            console.log('Final count for number 3:', allNumbers[3]);
            console.log('All numbers with their counts:', allNumbers);
            
            const missingNumbers = [];
            for (let i = 1; i <= 49; i++) {
                if (allNumbers[i] === 0) {
                    missingNumbers.push(i);
                }
            }
            
            console.log('Total draws analyzed:', data.length);
            console.log('Total numbers counted:', Object.values(allNumbers).reduce((a, b) => a + b, 0));
            console.log('Missing numbers (frequency = 0):', missingNumbers);
            console.log('Numbers with frequency > 0:', Object.entries(allNumbers).filter(([num, freq]) => freq > 0).length);
            
            return missingNumbers;
        }

        // Get latest winning numbers
        function getLatestWinningNumbers(data) {
            if (data.length === 0) return [];
            
            // Sort by date to get the most recent draw
            const sortedData = data.sort((a, b) => new Date(b.Date) - new Date(a.Date));
            const latestDraw = sortedData[0];
            
            // Use helper function to get winning numbers from any format
            return getWinningNumbers(latestDraw);
        }

        // Function to recompute predictions
        function recomputePredictions() {
            const button = document.getElementById('recompute-btn');
            const container = document.getElementById('predictions-container');
            
            // Show loading state
            button.disabled = true;
            button.innerHTML = `
                <svg class="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                </svg>
                Computing...
            `;
            
            container.innerHTML = `
                <div class="text-center py-8">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
                    <p class="mt-2 text-gray-600">Regenerating predictions...</p>
                </div>
            `;
            
            // Simulate some processing time for better UX
            setTimeout(() => {
                // Get latest winning numbers for highlighting
                const latestNumbers = getLatestWinningNumbers(totoData);
                
                // Generate new predictions
                const predictions = generatePredictions(totoData);
                renderPredictions(predictions, latestNumbers);
                
                // Update statistics and data table with new predictions
                renderStatistics(totoData, latestNumbers, predictions);
                renderDataTable(totoData, latestNumbers, predictions);
                
                // Update chart if it's currently visible
                const chartsTab = document.getElementById('charts-tab');
                if (!chartsTab.classList.contains('hidden')) {
                    renderChart(totoData, latestNumbers, predictions);
                }
                
                // Reset button
                button.disabled = false;
                button.innerHTML = `
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    Recompute Predictions
                `;
            }, 1000);
        }

        // Smart number generation based on frequency patterns
        function generateSmartNumbers() {
            try {
                // Analyze existing data for frequency patterns
                const frequency = {};
                for (let i = 1; i <= 49; i++) {
                    frequency[i] = 0;
                }
                
                // Count frequency of each number in existing data
                totoData.forEach(row => {
                    getWinningNumbers(row).forEach(num => {
                        if (num >= 1 && num <= 49) {
                            frequency[num] = (frequency[num] || 0) + 1;
                        }
                    });
                });
                
                // Get top frequent numbers
                const topFrequent = Object.entries(frequency)
                    .map(([number, freq]) => ({ number: parseInt(number), frequency: freq }))
                    .sort((a, b) => b.frequency - a.frequency)
                    .slice(0, 15) // Top 15 most frequent
                    .map(item => item.number);
                
                // Generate mix: 3 from frequent + 3 random
                const numbers = [];
                
                // Add 3 from most frequent
                for (let i = 0; i < 3 && topFrequent.length > 0; i++) {
                    const randomIndex = Math.floor(Math.random() * topFrequent.length);
                    const selected = topFrequent.splice(randomIndex, 1)[0];
                    numbers.push(selected);
                }
                
                // Fill remaining with random numbers
                while (numbers.length < 6) {
                    const randomNum = Math.floor(Math.random() * 49) + 1;
                    if (!numbers.includes(randomNum)) {
                        numbers.push(randomNum);
                    }
                }
                
                numbers.sort((a, b) => a - b);
                return numbers;
                
            } catch (error) {
                console.error('Error in generateSmartNumbers:', error);
                // Fallback: generate completely random numbers
                const fallbackNumbers = [];
                while (fallbackNumbers.length < 6) {
                    const randomNum = Math.floor(Math.random() * 49) + 1;
                    if (!fallbackNumbers.includes(randomNum)) {
                        fallbackNumbers.push(randomNum);
                    }
                }
                fallbackNumbers.sort((a, b) => a - b);
                return fallbackNumbers;
            }
        }

        // Initialize the application
        function init() {
            try {
                console.log('Initializing TOTO Analysis App...');
                
                // Debug: Check for missing numbers
                const missing = debugMissingNumbers(totoData);
                
                // Get latest winning numbers for highlighting
                const latestNumbers = getLatestWinningNumbers(totoData);
                
                updateSummaryCards(totoData);
                const predictions = generatePredictions(totoData);
                renderPredictions(predictions, latestNumbers);
                renderStatistics(totoData, latestNumbers, predictions); // Pass predictions
                renderDataTable(totoData, latestNumbers, predictions);
                
                // Render chart if charts tab is initially visible
                setTimeout(() => {
                    if (!document.getElementById('charts-tab').classList.contains('hidden')) {
                        renderChart(totoData, latestNumbers);
                    }
                }, 200);
                
                // Add event listeners
                document.getElementById('recompute-btn').addEventListener('click', recomputePredictions);
                document.getElementById('refresh-latest-btn').addEventListener('click', fetchLatestTotoData);
                
                // Add event listeners for chart prediction controls
                document.getElementById('select-all-predictions').addEventListener('click', () => {
                    document.querySelectorAll('.prediction-checkbox').forEach(checkbox => {
                        checkbox.checked = true;
                    });
                    updateChartDisplay();
                });
                
                document.getElementById('clear-all-predictions').addEventListener('click', () => {
                    document.querySelectorAll('.prediction-checkbox').forEach(checkbox => {
                        checkbox.checked = false;
                    });
                    updateChartDisplay();
                });
                
                // Set initial last updated timestamp
                document.getElementById('last-updated').textContent = 
                    `Last updated: ${new Date().toLocaleString()}`;
                
                console.log('TOTO Analysis App initialized successfully!');
                
                // Test the data generation function
                console.log('Testing data generation...');
                const testData = generateRealisticNewData();
                console.log('Test data generated successfully:', testData);
                
            } catch (error) {
                console.error('Error initializing app:', error);
            }
        }

        // Add a helpful note about data sources
        console.log('üéØ TOTO Analysis App - Standalone Version');
        console.log('üìä This app includes embedded historical TOTO data for full functionality');
        console.log('üîÑ Click "Refresh Latest Data" to attempt fetching from external sources');
        console.log('üí° For latest results, check Singapore Pools official website');
        console.log('‚ö° App works fully offline with embedded data');
        
        // Start the application when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html> 